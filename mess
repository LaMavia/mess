#!/usr/bin/env perl

use strict;
use warnings;
use warnings FATAL => 'all';
use File::Spec::Functions 'catfile';
use File::Basename;
use Cwd qw(abs_path getcwd);

sub get_config {
    # my ($file) = @_;
    # my (undef, $base) = fileparse $file;
    my $base = getcwd();
    print "base: $base\n";
    my %config = ( do "$base/mcf.pm" );

    return \%config;
}

sub get_or {
    my ($cr, $key, $default) = @_;
    my %config = %{$cr};

    return $config{$key} ? qr/@{[$config{$key}]}/m : $default;
}

sub init_re {
    my %config = %{$_[0]};
    my %re = ();

    my %static = (
        opening => qr/\{/m,
        closing => qr/\}/m,
        pre_key => qr//m,
        assign  => qr/:/m,
        pre_var => qr/\$/m,
        class   => qr//m
    );

    foreach my $k (keys %static) {
        $re{$k} = exists($config{$k}) ? qr/@{[$config{$k}]}/m : $static{$k};
    }

    my $rop = $re{"opening"};
    my $rcl = $re{"closing"};
    my $rpk = $re{"pre_key"};
    my $ras = $re{"assign"};
    my $rva = $re{"var"};

}
my %config       = %{get_config($ARGV[0])};
my $re_opening   = get_or(\%config, "opening", q/\{/);
my $re_closing   = get_or(\%config, "closing", q/\}/);
my $re_pre_key   = get_or(\%config, "pre_key", q//);
my $re_assign    = get_or(\%config, "assign" , q/:/);
my $re_var_pre   = get_or(\%config, "pre_var", q/\$/);
my $re_class_pre = get_or(\%config, "class"  , q//);
my $re_start =
  qr/^\s*$re_class_pre((?:(?!$re_opening|$re_closing|;).)*?)\s*$re_opening/;
my $re_identifier      = q/[^\s]+(?<!,)/;
my $re_identifier_list = q/\((?:\s*[^\s\(\)]+,?\s*)*\)/;
my $re_key             = qr/$re_pre_key((?:\w|~|\-|$re_var_pre)+)/;
my $re_val             = q/([^;]*?)/;
my $re_kv = qr/$re_key\s*$re_assign\s*$re_val\s*;/m; # <key>: val; => (key, val)
my $re_white_line = q/^\s*$/;
my $re_import     = q/@import\s*"([^"]+)";/;
my $re_var        = qr/$re_var_pre($re_identifier)/;

sub process_start {
    my ( $line, $path ) = @_;

    my ($name) = ( $line =~ $re_start );
    my $old_name = $name;
    $name =~ s/&/$path/;
    $line =~ s/\Q$old_name\E/$name/;
    $line =~ s/$re_opening/{/ if $re_opening;
    $line =~ s/$re_class_pre// if $re_class_pre;

    return ( $line, $name );
}

sub process_class {
    my ( $fst_line, $src, $name, $base_dir ) = @_;
    my ($base_indent) = ( $fst_line =~ /^(\s*)/ );
    $fst_line =~ s/^$base_indent//;

    my $out  = $fst_line;
    my @children = ();

    if ( $out =~ $re_closing ) {
        return $out;
    }

    while ( my $line = <$src> ) {
        my $matched = 0;
        $line =~ s/^\Q$base_indent\E//;
        my ($indent) = ( $line =~ /^(\s*)/ );
        if ( not $indent ) {
            $indent = "";
        }

        if ( $line =~ $re_start ) {
            ( $line, my $next_name ) = process_start( $line, $name );
            push(
                @children,
                process_class(
                    $base_indent . $line,
                    $src, $next_name, $base_dir
                )
            );
            $out =~ s/\s+$/\n/;
            $line = "";
        }
        if ( $line =~ $re_closing ) {
            $line =~ s/$re_closing/}/ if $re_closing;
            $out = $out . $line;
            last;
        }

        # vars
        if ( $line =~ $re_kv ) {
            my $key = ( my $old_key = $1 );
            my $val = ( my $old_val = $2 );

            $key =~ s/$re_var/--$1/;
            $val =~ s/$re_var/var(--$1)/;

            $line =~ s/\Q$old_key\E/$key/;
            $line =~ s/\Q$old_val\E/$val/;
            $line =~ s/$re_assign/:/ if $re_assign;
        }

        # mixins
        if ( $line =~ /#($re_identifier)/ ) {
            my $name = $1;
            if ( $name =~ /here/i ) {
                my $apath = abs_path($base_dir);
                $line =~ s/&here/$apath/gi;
            }
        }

        $out .= $line;
    }

    if ($#children > -1) {
        $out .= "\n";
    }
    for (@children) {
        $out = $out . "\n" . $_;
    }

    return $out;
}

sub process_file {
    my ($file, $save)   = @_;
    my $out_file = ( $file =~ s/\.mss/.css/r );
    my $out      = "";

    my ( undef, $base_dir ) = fileparse($file);
    open( my $src,  '<', $file )     or die "Could not open $file: $!";
    open( my $dist, '>', $out_file ) or die $! if $save;

    while ( my $line = <$src> ) {
        # imports
        if ( $line =~ $re_import ) {
            my $path = catfile( $base_dir, $1 );
            printf "importing %s\n", $path;
            my $res = process_file($path, 0);
            $res  =~ s/\s+$/\n/;
            $line =~ s/$re_import/$res/;
        }

        if ( $line =~ $re_start ) {
            my $next_name;
            ( $line, $next_name ) = process_start( $line, "" );
            $line = process_class( $line, $src, $next_name, $base_dir );
        }

        $out = $out . $line;
    }

    print $dist $out if $save;

    close $src;
    close $dist if $save;
    return $out;
}

process_file(@ARGV, 1);
